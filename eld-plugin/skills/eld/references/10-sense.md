# Sense（感知）フェーズ

コードの事実・意図・関係を観測し、身体図を更新する。

## 目的

- コードを「テキスト」ではなく「相互接続された意味のグラフ」として理解
- 曖昧さを「unknown」として明示
- 変更の影響範囲を把握

## 原則

**ファイルを全部読むのではなく、まず「地図」を作り、必要な場所だけを「拡大鏡」で読む。**

## 感知ツール選択ガイド

**目的に応じて最適なツールを選択する。**

| 目的 | 最適ツール | 理由 |
|------|-----------|------|
| **特定キーワード検索** | `Grep` | 正規表現で高速・確実。パターンが明確な時 |
| **ファイルパターン検索** | `Glob` | `**/*.ts` 等で高速にファイル特定 |
| **定義・参照追跡** | `LSP` / `serena` | 言語理解に基づく正確な追跡 |
| **シンボル検索・編集** | `serena` | LSP + シンボル単位編集。言語サーバー対応時 |
| **特定ファイル読み込み** | `Read` | パスが分かっている時に直接的 |
| **意味的関連探索** | `kiri context_bundle` | ゴールベースでセマンティック検索 |
| **依存関係分析** | `kiri deps_closure` | 構造的な影響範囲分析 |
| **広範囲の複雑な探索** | `Task (Explore)` | 複数ツール組み合わせの並列調査 |

### serena MCP（利用可能時）

serenaはLSP機能をMCPサーバーとして提供する。`.serena/project.yml`がある場合に利用可能。

**主要ツール**:
- `find_symbol`: グローバルシンボル検索
- `find_referencing_symbols`: 参照元シンボル検索
- `find_referencing_code_snippets`: 参照コードスニペット取得
- `get_symbols_overview`: ファイル内シンボル一覧
- `replace_symbol_body`: シンボル単位での置換

### ツール選択フローチャート

```
目的は何か？
├─ 特定文字列を探す → Grep
├─ ファイル名パターンで探す → Glob
├─ 定義元/参照先を追う → LSP / serena
├─ シンボル検索・編集 → serena（利用可能時）
├─ パスが分かっている → Read
├─ 「〜に関連するコード」を探す → kiri context_bundle
├─ 依存グラフが必要 → kiri deps_closure
└─ 複雑で広範囲 → Task (Explore)
```

## 感知ワークフロー

### Step 1: ゴールベース検索

```
context_bundle({
  goal: "<達成したいこと/調査したいこと>",
  category: "bugfix" | "feature" | "debug" | ...
})
```

### Step 2: 記憶の活性化

```
pce.memory.activate({
  q: "<検索キーワード>",
  scope: ["project"],
  top_k: 10
})
```

### Step 3: 鮮度チェック

取得した各エントリについて:
1. `last_verified_at` を確認
2. TTLと比較
3. 超過なら自動降格（verified→inferred→unknown）

### Step 4: JIT再解析（必要時のみ）

```
1. context_bundle({goal: "<エンティティ関連のゴール>"})
2. snippets_get({path: "<該当ファイル>"}) で詳細取得
3. 新しい解釈を生成
4. pce.memory.upsert で更新
```

## 次フェーズとの接続

- Sense → **Spec**: 観測結果をSpecフェーズのVocabulary/Law同定に入力
- Sense → **Predict-Light**: 影響範囲の事前把握がP0/P1/P2判定に活用される

## 身体図の更新

### レイヤー構成

| レイヤー | 内容 | 更新タイミング |
|----------|------|----------------|
| シンボル | 関数/クラス/型 | コード変更時 |
| 設定 | 環境変数/設定ファイル | 設定変更時 |
| データ | DB/外部API/ファイル | スキーマ変更時 |
| 境界 | 入出力インターフェース | API変更時 |

### 影響範囲分析

```
deps_closure({
  path: "<対象ファイル>",
  direction: "inbound"  // または "outbound"
})
```

## リソース制限

1回の感知に対する上限:

| リソース | 上限 |
|----------|------|
| files_search 実行回数 | 3回 |
| snippets_get 対象ファイル数 | 5ファイル |
| deps_closure 再帰深度 | 2 |
| 1ファイルあたりの読み取り行数 | 200行 |

## Epistemic Status の明示

感知結果には必ずEpistemic Statusを付与:

```markdown
## 回答

<回答本文>

### 根拠 [verified]

- `src/services/AuthService.ts:45-67` - ログイン処理の実装
- `src/db/UserRepo.ts:23` - ユーザー検索クエリ

### 推論 [inferred]

- パターンから推測すると、エラーハンドリングは上位レイヤーで行われている

### 未確認 [unknown]

- 外部APIの仕様に依存する部分は確認が必要
- 確認推奨箇所: `src/payment/Gateway.ts:95`
```

## 感知の限界宣言

以下の場合は正直に不明であると宣言:

- pce-memoryに情報がなく、コード検索ツールでも解読困難
- ロジックが複雑すぎて確信が持てない
- 外部サービスの仕様に依存する部分
- DI/生成/設定駆動で静的に追跡困難

## チェックリスト

- [ ] ゴールベース検索を最初に実行したか
- [ ] 記憶の活性化と鮮度チェックを行ったか
- [ ] 身体図の関連レイヤーを更新したか
- [ ] Epistemic Statusを明示したか
- [ ] 不明な点を「unknown」として宣言したか
- [ ] リソース制限を守ったか
