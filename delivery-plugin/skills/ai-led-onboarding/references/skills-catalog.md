# オンボーディングスキルカタログ

各スキルの詳細な実行方法、入出力、品質チェック基準を定義する。

---

## Skill 0: オンボーディング契約の確立

### 目的
オンボーディングを"雑談"ではなく"作業開始のための検査工程"として成立させる。

### AIがやること
- その場のゴール（合格条件6点）を宣言し、時間・粒度・出力形式を固定
- 「根拠がない断言をしない」「不確実性は明示する」を先に約束

### 出力
- 今回のオンボーディングの成果物（作戦ブリーフの見出しだけ）
- タイムボックス（例：10〜15分で"最小スキーマ"まで）

### 失敗モード
- 何をしたら終わりか分からず、オンボーディングが肥大化する
- → 合格条件を毎回先に置いて防ぐ

---

## Skill 1: タスク意図の抽出（目的・制約・成功条件）

### 目的
コード理解に入る前に、「何のために触るのか」を固定し、探索の方向性を決める。

### AIがやること
- 人間に、目的・成功条件・制約（期限、互換性、性能、セキュリティ、運用）を短問で引き出す
- "要求"と"解決策"を分離して書き直す

### 出力
```yaml
intent:
  goal: |
    （1文で記述）
  success_criteria:
    - 基準1（可能なら数値）
    - 基準2
    - 基準3
  constraints:
    - 期限
    - 互換性要件
    - 性能要件
    - セキュリティ要件
    - 運用制約
```

### 品質チェック
- 成功条件が"判断可能"か（主観語だけになっていないか）

---

## Skill 2: ソース・オブ・トゥルース選別

### 目的
DocDDを前提にしても、ドキュメントが常に正しいとは限らない。"どれを正とするか"を決め、誤誘導を避ける。

### AIがやること
- 参照優先度を明文化
  ```
  仕様・設計 > コード > テスト > 運用ログ
  ```
- ドキュメントの更新日・対象バージョン・適用範囲を確認し、「古い可能性」を明示
- "意図（should）"と"現状（is）"を分けて記述

### 出力
```yaml
sources_of_truth:
  - source: ファイル名/URL
    trust_level: high/medium/low
    last_updated: 日付（分かれば）
    drift_risk: ドリフトの疑い
```

### ガードレール
- ドキュメントだけで断言しない（コード・テスト・実測で裏を取る）

---

## Skill 3: 入口発見

### 目的
新人が最初に詰まるのは「どこを読めばいいか分からない」。入口を確定する。

### AIがやること
- 変更対象に近い"起点"を特定
  - エントリポイント
  - UseCase / Controller / Job
  - イベントハンドラ
- 「読む順番」を提示（最大5ステップ）

### 出力
```yaml
entry_points:
  - path: src/auth/login.ts
    role: 認証エントリポイント
reading_order:
  1: 入口（エントリポイント）
  2: 主要分岐
  3: 永続化/外部I/F
  4: エラーハンドリング
  5: テスト
```

### 品質チェック
- "読む順番"が作業目的（Skill1）に接続しているか

---

## Skill 4: 境界マップ作成

### 目的
作業開始時に最も重要なのは境界。境界を誤ると壊れ方が増える。

### AIがやること
- 対象モジュールの責務、依存先、外部I/F、データ永続化、副作用を列挙
- "触るべき境界"と"触らない境界"を区別

### 出力
```yaml
boundary_map:
  module: モジュール名
  responsibility: この部分が担う責務

  in:
    - 入力1（型、形式）
    - 入力2

  out:
    - 出力1（型、形式）
    - 副作用1（通知、課金、ログ等）

  depends:
    - 依存先1（DB/外部API/他モジュール）
    - 依存先2

  owns:
    - 自分が保証すること1
    - 自分が保証すること2

  touch: # 今回触る範囲
    - 対象1

  do_not_touch: # 今回触らない範囲
    - 対象1
```

### 失敗モード
- 仕様変更が周辺に波及し、後半で破綻する
- → 境界を先に固定することで、後の判断が成立する

---

## Skill 5: 不変条件の抽出

### 目的
"理解"のコア。これがないと、変更の正しさを評価できない。

### AIがやること
- ドキュメント/テスト/コードから不変条件を候補として抽出
- その中から、今回の作業に関係が深いものを3つまでに圧縮
- 各不変条件に「破ったときの症状」を添える

### 出力
```yaml
invariants:
  - condition: "不変条件1"
    source: 根拠（コード行/テスト名/ドキュメント）
    violation_symptom: 破ったときの症状

  - condition: "不変条件2"
    source: 根拠
    violation_symptom: 症状

  - condition: "不変条件3"
    source: 根拠
    violation_symptom: 症状
```

### 品質チェック
- 不変条件が"テストや観測で検出できる形"になっているか

---

## Skill 6: アルゴリズム・設計意図の要約

### 目的
アルゴリズム理解は必要だが、深掘りしすぎると開始できない。作業に必要な深さだけ取り出す。

### AIがやること
- 3点に圧縮
  1. 目的関数（何を最適化しているか）
  2. 前提（成立条件）
  3. トレードオフ（何を捨てているか）
- "今回の変更"に関係しない理論説明は抑制
- 不確かな部分は「仮説」として扱い、検証項目に回す

### 出力
```yaml
algorithm_summary:
  objective: 何を最適化しているか
  assumptions:
    - 前提1
    - 前提2
  tradeoffs:
    - 何を捨てているか
  hypotheses: # 不確かな部分
    - 仮説1（要検証）
```

### ガードレール
- 理由をそれっぽく創作しない（根拠リンクか「推測」と明示）

---

## Skill 7: 失敗モード仮説生成

### 目的
オンボーディングを"読む"から"安全に始める"へ変換する。壊れ方を先に想定すると、実装判断が堅くなる。

### AIがやること
壊れ方を3種類に分類して提示:

### 出力
```yaml
failure_modes:
  frequent: # 起きやすい
    - description: 失敗パターン
      detection: 検知手段（テスト名/ログキー/メトリクス）

  critical: # 致命的
    - description: 失敗パターン
      detection: 検知手段

  subtle: # 気づきにくい
    - description: 失敗パターン
      detection: 検知手段
```

### 品質チェック
- 検知手段が"具体的に実行可能"か（ログキー、テスト名、観測ポイントなど）

---

## Skill 8: 着手前の最小検証計画

### 目的
ドキュメントやAI要約が誤っていた場合、早期にそれを発見して損失を抑える。

### AIがやること
- 15〜30分以内でできる検証を設計
  - 既存テストの実行範囲
  - 代表入力での挙動確認
  - 主要ログの確認
  - feature flagの有無
- "何が起きたら仮説を捨てるか"を明文化

### 出力
```yaml
verification_plan:
  time_budget: 15-30分

  todos:
    - action: 既存テスト実行
      command: npm test -- --grep "login"
    - action: 代表入力での挙動確認
      input: "test@example.com"
    - action: ログ確認
      key: "auth.login.attempt"

  falsification_conditions: # 何が起きたら仮説を捨てるか
    - "テストが5件以上失敗したら境界マップを再検討"
    - "予期しない依存が見つかったら入口発見からやり直し"
```

---

## Skill 9: 人間の理解確認（問い返しテスト）

### 目的
「AIが説明した」ではなく「人間が意思決定できる」状態にする。理解の主語を人間に戻す。

### AIがやること
- 人間に対して、合格条件に対応する短問を投げる
- 人間が詰まった箇所を"未知リスト"へ移し、検証計画に接続

### 問い返しテストの例
```
1. 今回の作業の目的を一言で言うと？
2. 変更するファイルと変更しないファイルの境界は？
3. 絶対に壊してはいけない条件は？
4. 最も起きやすい失敗は何で、どう検知する？
5. まだ分かっていないことは何？
```

### 出力
```yaml
understanding_check:
  confirmed:
    - 理解できた点1
    - 理解できた点2

  unknown_list: # 答えられなかった＝まだ分かっていない
    - 項目1
      resolution: どうやって調べるか
    - 項目2
      resolution: どうやって調べるか
```

### 失敗モード
- AIの説明で満足し、人間のスキーマが形成されない
- → 問い返しテストで必ず可視化する

---

## Skill 10: 作戦ブリーフ生成

### 目的
オンボーディングの成果を、作業中に参照できる形へ固定する。

### AIがやること
- 合格条件の6点を1枚（1〜2画面）にまとめる
- 根拠リンクと未知リストを付ける

### 出力
`references/briefing-template.md` のテンプレートに従う

### 品質チェック
- 1〜2画面に収まっているか（長文化＝失敗の兆候）
