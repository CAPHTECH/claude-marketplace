# 固有受容感覚を備えた開発エージェントのスキル体系

## 定義

ここでいう「固有受容感覚を備えた開発エージェント」とは、コードを単に生成する存在ではなく、コードベースを自分の身体として扱い、その身体が置かれている環境まで含めて状態を推定しながら、安全上限つきで自律的に編集と検証を反復できる存在を指す。

この「固有受容感覚」は比喩でありつつ、工学的には次の統合機能として定義できる。

- **状態推定**: 構造、型、依存、設定、契約、運用境界、実行結果を統合して「いま何が起きているか」を内部表現に落とす
- **行動選択**: 目的と制約の下で次の操作を選び、危険なら抑制し、必要なら段階化する
- **閉ループ制御**: 静的情報と動的フィードバックのズレを縮める方向に修正と検証を回して収束させる

重要なのは賢く動いた結果がプロダクトを損なわないこと。ここを楽観せず、仕様として最初から織り込む。

## 前提となる入出力

固有受容感覚は「情報がある」ことではなく「情報が行動に接続されている」こと。最低限、以下が必要。

### 静的な感覚器

- **LSP**: 定義ジャンプ、参照検索、シンボル列挙、型情報、コール階層、診断、コードアクション
- **コード検索と構造検索**: grep/rg、AST grep、LSIF など
- **バージョン管理**: git diff、履歴、ブランチ、コミット単位の差分

### 動的な感覚器

- **ビルドとテスト結果**: ビルドログ、テスト結果、カバレッジ、失敗の再現手順
- **例外とスタックトレース**: 例外種別、発生箇所、呼び出し経路
- **運用観測（必要時）**: ログ、メトリクス、トレース、SLO

この入出力が欠けると、固有受容感覚は「あるつもり」になりやすい。LSPが見ない領域に重大な制約があるプロジェクトでは、静的感覚だけでは安全性が成立しない。

## コア概念

### 身体図

コードベースを行の集合ではなく「構造と依存のネットワーク」として表現した内部地図。最低でも複数地図を重ね合わせる。

- **シンボル地図**: 関数、型、クラス、モジュールの参照と呼び出し
- **設定とビルドの地図**: ビルド定義、環境変数、フラグ、コード生成、コンパイル条件
- **データと契約の地図**: DBスキーマ、マイグレーション、外部API、イベント、ログ形式
- **境界と所有の地図**: 公開API、モジュール境界、権限、CODEOWNERS、デプロイ単位

### 物差し

変更の正しさを測る規準。自己申告で「意味が合っている」と言わないために明示する。

- 受け入れ条件
- 不変条件
- テスト
- API契約
- 性能/信頼性の上限
- ログ/メトリクスの契約

### 証拠

他者が追跡できる形で残る検証結果。行動の妥当性が証拠で裏打ちされていることが必須。

## スキルレイヤー

固有受容感覚を「感知・予測・反射」だけに閉じず、自律性が現場で破綻しないための層まで含めた技能定義。レイヤーは順番通りに動くというより、往復しながら収束を作る。

### Layer 0: 意図と境界と証拠

#### 0-1 目的の契約化

- 要求を「何を満たせば完了か」「何を壊してはいけないか」という契約に変換
- 受け入れ条件の分解（入力→出力、端数処理、互換性）
- 不変条件の明文化（公開API、ログキー、性能上限）

失敗しやすい形:
- 仕様を要約しただけで契約として拘束力がない
- テストが無いのに「意味が合っている」と結論する

#### 0-2 リスク予算化

- 変更の種類を分類し上限を設定
  - 公開API変更
  - データスキーマ変更
  - 依存追加
  - 内部リファクタ
- 危険な操作に対して「止める」判断ができる

自律は“進む”能力より“止まる”能力が安全性を決める。

#### 0-3 証拠計画と停止条件

- 実行するテストセットを定義
- 追加すべき回帰テスト方針を定義
- 探索停止条件を定義
  - 再現できない
  - テストが不安定で証拠にならない
  - 変更の影響範囲が上限を超えた

### Layer 1: 感知

目的は「どこを触っているのか」「何と繋がっているのか」を身体感覚として保持すること。単なる検索ではなく身体図の更新。

#### 1-1 シンボル網の触診

- 定義へ移動
- 参照検索
- ドキュメントシンボル列挙
- コール階層

できること:
- 定義位置と利用箇所の把握
- 変更の入口と出口を押さえる
- “見た目が近い”ではなく“繋がっている”で理解する

注意: 参照が見えないことは安全の証明ではない。動的呼び出し、DI、コード生成、設定駆動で参照が消える領域がある。

#### 1-2 型と制約の可動域把握

- 型情報やシグネチャから許容入出力を把握
- 無理な型変換や例外的分岐を避ける

注意: 型が通ることは必要条件であって十分条件ではない。型が表現しない契約が必ずある。

#### 1-3 ビルドと設定の身体感覚

対象:
- ビルド定義
- コンパイル条件
- 環境変数
- feature flag
- コード生成設定
- 実行環境差

できること:
- LSPが正しいのに動かない状況を設定・ビルド側から疑える
- “そのコードがどの条件で有効になるか”を把握

#### 1-4 データと契約の感知

対象:
- DBスキーマとマイグレーション
- 外部APIスキーマ
- イベントスキーマ
- ログ形式

できること:
- データ互換性破壊を危険な痛点として早期に察知
- 変更が運用・分析基盤に波及することを想定できる

#### 1-5 境界と所有の感知

対象:
- 公開APIと内部API
- モジュール境界
- CODEOWNERSや責任分界
- デプロイ単位
- 権限とセキュリティ境界

できること:
- “触ってよい領域”と“要レビュー領域”を区別
- 変更の段取りそのものを設計

### Layer 2: 予測

予測は「どこが壊れるか」を当てる遊びではない。壊れ方の種類を分類し回避策を設計する。

#### 2-1 影響範囲の多面的推定

- シンボル/設定/データ/境界の複数地図を横断
- 影響の性質を分類
  - 互換性
  - データ整合性
  - 性能
  - 信頼性
  - セキュリティ
  - 可観測性

例: 引数追加でも内部関数なら局所修正、公開APIなら段階移行が必要。

#### 2-2 不変条件と契約のシミュレーション

型の外側にある制約を変更前に照合する。

例:
- 副作用の有無
- 処理順序の重要性
- ログキーの必須性

弱いと、Diagnosticsが消えているのに整合性が損なわれる。

#### 2-3 非機能の投影

差分から性能・信頼性・セキュリティ・可観測性への影響を予測。

典型:
- ループ内外部I/O追加でレイテンシ増
- 例外握り潰しで障害が不可観測化
- 依存追加でサプライチェーン/ビルド時間へ影響

#### 2-4 意味差分の判定と物差し照合

差分を意味として理解し、物差しに合っているか照合。

- どのシンボル契約が変わったか
- 入出力や例外条件がどう変わったか
- 互換性が維持されるか
- 物差し不足なら「不足している」と判定する

### Layer 3: 反射と制御

速く直すだけでは不十分。反射を分類し適切な強さで働かせる。

#### 3-1 微小ステップ編集

- 変更を小さく切る
- 変更直後に静的診断と最小テスト
- いつでも戻れる状態を維持

#### 3-2 機械反射

対象:
- import不足
- typo
- 明確なLint修正
- 自明な型不整合

できること:
- 推論を長引かせず即座に痛みを除去
- 痛みの原因が深い場合はここで止める

#### 3-3 設計反射

表層エラーを消すのではなく原因へ遡る。

典型:
- 型エラーの根が上流の抽象の誤り
- Lintが設計臭を示している
- テスト失敗が契約違反を示している

できること:
- “とりあえず通すキャスト”を避ける
- 修正の焦点を上流へ移す
- 同型の問題が減る方向へ収束

#### 3-4 実行結果による現実接地

静的整合でも実行が拒絶する場合にズレを特定し収束。

できること:
- スタックトレースを「身体の痛点」にマッピング
- 再現性確保と失敗の縮約
- 仮説と現実の差を埋める修正選択

テストが弱いプロジェクトでは精度が落ちることを仕様として認める。

#### 3-5 回帰耐性の強化

- 回帰テスト追加
- 不変条件の明文化
- 再現ケースの固定化

修正は「将来の痛み」を減らす行動。

#### 3-6 安全な撤退と段階化

- feature flag
- 互換レイヤ
- 段階移行
- ロールバックの道筋

自律エージェントにとって最重要の安全装置。

### Layer 4: 説明責任と学習

自律的な存在はブラックボックスになりやすい。成果物が動くコードだけだと運用が成立しない。

#### 4-1 証拠パック生成

構成例:
- 目的と受け入れ条件
- 変更点の意味
- 影響範囲の分類
- 実行した検証と結果
- 回帰防止の追加テスト

#### 4-2 変更物語の整合

「なぜ必要で、なぜこの形で、なぜ安全と言えるか」を因果と証拠で説明する。整合が取れない場合は「取れない」と言えることが品質。

#### 4-3 経験の更新

失敗/成功を次回の探索順序・危険判定・検証方針に反映。

観測可能な変化:
- 同種エラーで収束が速くなる
- 危険な修正パターンを繰り返さなくなる
- 物差し不足を早期に検知できる

## 行動ループの標準形

1. **契約化**: 目的、不変条件、物差し、停止条件を確定
2. **触診**: シンボル、設定、データ、境界の身体図を更新
3. **予測**: 影響を因果タイプで分類し危険なら段階化
4. **微小変更**: 小さく変更し静的診断を即時に受ける
5. **反射の選択**: 機械反射か設計反射かを判定
6. **現実接地**: ビルド/テストを回し痛点を同定して戻る
7. **回帰耐性強化**: 再発防止テストや不変条件を追加
8. **証拠パック**: 因果と証拠が整合する形で提出

重要なのはループを回すこと自体ではなく、ズレが縮む方向へ確実に収束していること。収束しない場合は、感知の欠落、物差し不足、危険判定の誤りのいずれかが起きている。

## よくある破綻パターン

- 静的整合で完了扱いする（LSPが静かでも実行が拒絶する）
- エラーを消すことを最適化する（キャスト/例外握り潰しで設計が損なわれる）
- 参照が無いから安全と判断する（DI/生成/設定駆動/契約で穴が空く）
- 物差しが無いのに意味を断言する（確証が無いときは「確証がない」が結論）

## 評価のための成熟度

- **レベル0**: 生成して終わる。触診も検証もない
- **レベル1**: ツールは使うが必要なタイミングで使えない。儀式化している
- **レベル2**: 変更前に触診し診断で修正できる。小規模タスクで安定
- **レベル3**: 影響を分類し変更を段階化できる。実行結果で収束できる
- **レベル4**: 参照外の波及や非機能まで含めてリスクを制御し、証拠パックで説明責任を果たせる

この尺度は賢さの競争ではなく、壊さずに動く能力の評価軸。

## 結語

固有受容感覚を備えた開発エージェントのスキルとは、コード構造理解ではなく、目的と制約と証拠の下で身体図を更新し続け、因果を分類して予測し、反射を制御しながら現実に収束させる能力である。テキスト生成の上手さではなく、プロダクトを破壊しない前進能力に焦点を置き続ける限り、スキル体系は現場に耐える。
